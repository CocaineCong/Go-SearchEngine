# RoaringBitmap 相关

tangseng中的倒排索引结构为:

```go
string : roaring.BitMap
```

key 为`string类型`,也就是我们的具体的term字段词。 value 为`roaring.BitMap`类型, 也就是我们存储具体的term的所在的id。

eg:
1: 那里湖面总是澄清
2: 那里空气充满宁静

我们将上述文本进行倒排索引构建,于是就成了这个样子

```go
string: roaring.BitMap
那里: [1,2]
湖面: [1]
总是: [1]
澄清: [1]
空气: [2]
充满: [2]
宁静: [2]
```

## why roaring.BitMap?

一开始选型的时候，想过很多存储倒排索引id的结构，直接list存储，或者bitmap存储，

假设我们的数据集中有 800000 篇文章，每篇文章有 200 词条，每个词条有6个字符，倒排记录数目是 1 亿。那么如果我们倒排索引表中单单记录文档id，不记录文档内的频率和偏移信息。

那么 文档id 的长度就必须是 $log_2800000=20 bit$ （文档可能每篇文章都存在，所以是以最长的长度要求），所以我们整个未压缩的倒排索引表的大小大概有，倒排记录数 * 文档id大小 = **`100,000,000 * 20/8 = 250 MB`**

为了设计出一个更高效的倒排文件的表示方式，可以考虑每篇文档采用少雨20位的表示方法，观察中发现。高频词出现的文档id的序列相差不大。比如高频词 “大学”，我们去找一篇包含 大学 的文档，可能我们找了一个之后，不久又找到一个，这些文档id之间的gap(间距)不大，因此可以考虑用比20位端很多的位数来表示它。**`为了对这种间距分布的情况进行空间压缩，需要使用一种变长编码方法，这种方法可以对短间距采用更短的位数来表示`**

![在这里插入图片描述](https://img-blog.csdnimg.cn/fcee7be8fb2741db8737519253dff3e4.png)

而此时我们